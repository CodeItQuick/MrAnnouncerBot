@page
@model DieRollerModel
@{
  Layout = null;
}

@*<link rel="icon" href="data:,">*@
<!DOCTYPE html>

@*<canvas id="myFrontCanvas" width="1920" height="1080"></canvas>*@

<script src="~/lib/signalr/signalr.js"></script>

<!-- Order is important! -->
@*
<script src="~/GameDev/Source/Game Engine/Folders.js"></script>

<script>
  Folders.assets = 'GameDev/Assets/';
</script>*@

@*
<script src="~/GameDev/Source/Game Engine/Vector.js"></script>*@

<script>
  //connectToSignalR(signalR);
</script>

<body style="margin: 0">
  <div id="container"></div>
  @*
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>*@
  <script src="~/lib/dice/node_modules/three/build/three.js"></script>
  <script src="~/lib/dice/node_modules/cannon/build/cannon.js"></script>
  <script src="~/lib/dice/node_modules/three/examples/js/controls/OrbitControls.js"></script>
  <script src="~/lib/dice/node_modules/three/examples/js/libs/stats.min.js"></script>
  <script src="~/lib/dice/dice.js"></script>

  @*
  <script src="source/DiceD4.js"></script>
  <script src="source/DiceD6.js"></script>
  <script src="source/DiceD8.js"></script>
  <script src="source/DiceD10.js"></script>
  <script src="source/DiceD12.js"></script>
  <script src="source/DiceD20.js"></script>
  <script src="source/DiceManagerClass.js"></script>
  <script src="source/DiceObject.js"></script>*@

  <!--<script type="text/javascript" src="../teal.js"></script>
  <script type="text/javascript" src="dice.js"></script>-->
  <div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>
  <script>
    var container, scene, camera, renderer, controls, stats, world, dice = [];
    //import * as DICE from './lib/dice/dice.js'
    //import * as CANNON from './lib/dice/cannon.min.js';


    function init() { // From Rolling.html example.
      // SCENE
      scene = new THREE.Scene();
      // CAMERA
      //var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
      var SCREEN_WIDTH = 1920, SCREEN_HEIGHT = 1080;
      var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.01, FAR = 20000;
      camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
      scene.add(camera);
      camera.position.set(0, 30, 0);
      // RENDERER
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setClearColor(0x000000, 0);

      renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      container = document.getElementById('ThreeJS');
      container.appendChild(renderer.domElement);
      // EVENTS
      // CONTROLS
      controls = new THREE.OrbitControls(camera, renderer.domElement);

      //// STATS
      //stats = new Stats();
      //stats.domElement.style.position = 'absolute';
      //stats.domElement.style.bottom = '0px';
      //stats.domElement.style.zIndex = 100;
      //container.appendChild(stats.domElement);

      let ambient = new THREE.AmbientLight('#ffffff', 0.35);
      scene.add(ambient);

      let directionalLight = new THREE.DirectionalLight('#ffffff', 0.25);
      directionalLight.position.x = -1000;
      directionalLight.position.y = 1000;
      directionalLight.position.z = 1000;
      scene.add(directionalLight);

      let light = new THREE.SpotLight(0xefdfd5, 0.7);
      light.position.x = 10;
      light.position.y = 100;
      light.position.z = 10;
      light.target.position.set(0, 0, 0);
      light.castShadow = true;
      light.shadow.camera.near = 50;
      light.shadow.camera.far = 110;
      light.shadow.mapSize.width = 1024;
      light.shadow.mapSize.height = 1024;
      
      scene.add(light);


      var material = new THREE.ShadowMaterial();
      material.opacity = 0.5;

      var geometry = new THREE.PlaneGeometry(1000, 1000, 1, 1);
      var mesh = new THREE.Mesh(geometry, material);
      mesh.receiveShadow = true;
      mesh.rotation.x = -Math.PI / 2;
      scene.add(mesh);

      ////////////
      // CUSTOM //
      ////////////
      world = new CANNON.World();

      world.gravity.set(0, -9.82 * 20, 0);
      world.broadphase = new CANNON.NaiveBroadphase();
      world.solver.iterations = 32;

      DiceManager.setWorld(world);

      // create the sphere's material
      const wallMaterial =
        new THREE.MeshLambertMaterial(
          {
            color: 0xA00050
          });

      const wallThickness = 1;
      const leftWallWidth = 50;
      const leftWallHeight = 3;
      const leftWallX = -21.5;

      const topWallWidth = 50;
      const topWallHeight = 3;
      const topWallZ = -12.5;

      const playerTopWallWidth = 30;
      const playerTopWallHeight = 3;
      const playerTopWallZ = 5;
      const playerTopWallX = -5;

      const showWalls = false;
      const addPlayerWall = true;
      if (showWalls) {
        const leftWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, leftWallHeight, leftWallWidth), wallMaterial);
        leftWall.position.x = leftWallX;
        scene.add(leftWall);

        const topWall = new THREE.Mesh(new THREE.BoxGeometry(topWallWidth, topWallHeight, wallThickness), wallMaterial);
        topWall.position.z = topWallZ;
        scene.add(topWall);

        if (addPlayerWall) {
          const playerTopWall = new THREE.Mesh(new THREE.BoxGeometry(playerTopWallWidth, playerTopWallHeight, wallThickness), wallMaterial);
          playerTopWall.position.x = playerTopWallX;
          playerTopWall.position.z = playerTopWallZ;
          scene.add(playerTopWall);
        }
      }


      // Floor
      let floorBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane(), material: DiceManager.floorBodyMaterial });
      floorBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
      floorBody.name = 'floor';
      world.add(floorBody);

      //Walls
      let rightWall = new CANNON.Body({ mass: 0, shape: new CANNON.Plane(), material: DiceManager.barrierBodyMaterial });
      rightWall.name = 'wall';
      rightWall.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -Math.PI / 2);
      rightWall.position.x = 20.5;
      world.add(rightWall);

      let bottomWall = new CANNON.Body({ mass: 0, shape: new CANNON.Plane(), material: DiceManager.barrierBodyMaterial });
      bottomWall.name = 'wall';
      bottomWall.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -Math.PI / 2 * 2);
      bottomWall.position.z = 11.5;
      world.add(bottomWall);

      var wallDiceContactMaterial = new CANNON.ContactMaterial(DiceManager.barrierBodyMaterial, DiceManager.diceBodyMaterial, { friction: 0.0, restitution: 0.9 });
      world.addContactMaterial(wallDiceContactMaterial);

      //let leftWall = new CANNON.Body({ mass: 0, shape: new CANNON.Plane(), material: DiceManager.floorBodyMaterial });
      //leftWall.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -Math.PI / 2);
      //leftWall.position.x = -20;
      //world.add(leftWall);

      let topCannonWall = new CANNON.Body({ mass: 0, shape: new CANNON.Box(new CANNON.Vec3(topWallWidth, topWallHeight, wallThickness)), material: DiceManager.barrierBodyMaterial });
      topCannonWall.name = 'wall';
      topCannonWall.position.z = topWallZ;
      world.add(topCannonWall);

      let leftCannonWall = new CANNON.Body({ mass: 0, shape: new CANNON.Box(new CANNON.Vec3(wallThickness, leftWallHeight, leftWallWidth)), material: DiceManager.barrierBodyMaterial });
      leftCannonWall.name = 'wall';
      leftCannonWall.position.x = leftWallX;
      world.add(leftCannonWall);


      if (addPlayerWall) {
        let playerTopCannonWall = new CANNON.Body({ mass: 0, shape: new CANNON.Box(new CANNON.Vec3(playerTopWallWidth * 0.5, playerTopWallHeight, wallThickness)), material: DiceManager.barrierBodyMaterial });
        playerTopCannonWall.name = 'wall';
        playerTopCannonWall.position.x = playerTopWallX;
        playerTopCannonWall.position.z = playerTopWallZ;
        world.add(playerTopCannonWall);
      }

      //var groundShape = new CANNON.Plane();
      //var groundBody = new CANNON.Body({ mass: 0 });
      //groundBody.addShape(groundShape);
      //groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
      //world.add(groundBody);


      var colors = ['#ff0000', '#ffff00', '#00ff00', '#0000ff', '#ff00ff'];
      var diceToRoll = 2;
      for (var i = 0; i < diceToRoll; i++) {
        //var die = new DiceD20({ size: 1.5, backColor: colors[i] });
        var die = new DiceD20({ size: 1.5, backColor: '#D0D0ff' });
        scene.add(die.getObject());
        dice.push(die);
      }

      function randomDiceThrow() {
        var diceValues = [];
        
        for (var i = 0; i < dice.length; i++) {
          let yRand = Math.random() * 20
          let die = dice[i].getObject();
          die.position.x = -15 - (i % 3) * 1.5;
          die.position.y = 4 + Math.floor(i / 3) * 1.5;
          die.position.z = -13 + (i % 3) * 1.5;
          die.quaternion.x = (Math.random() * 90 - 45) * Math.PI / 180;
          die.quaternion.z = (Math.random() * 90 - 45) * Math.PI / 180;
          dice[i].updateBodyFromMesh();
          let rand = Math.random() * 5;
          die.body.velocity.set(35 + rand, 10 + yRand, 25 + rand);
          die.body.angularVelocity.set(20 * Math.random() - 10, 20 * Math.random() - 10, 20 * Math.random() - 10);

          diceValues.push({ dice: dice[i], value: Math.floor(Math.random() * 20 + 1) });
          die.body.name = 'die';
        }

        DiceManager.prepareValues(diceValues);

        for (var i = 0; i < dice.length; i++) {
          let die = dice[i].getObject();~
          die.body.addEventListener("collide", function (e) {
            if (!DiceManager.throwRunning) {
              var relativeVelocity = Math.abs(Math.round(e.contact.getImpactVelocityAlongNormal()));
              console.log(e.target.name + ' -> ' + e.body.name + ' at ' + relativeVelocity + 'm/s');
              var v = e.target.velocity;
              // <formula \sqrt{x^2 + y^2 + z^2}>
              console.log('Target Velocity: ' + Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z));
            }
          });
        }

      }

      setInterval(randomDiceThrow, 5000);
      randomDiceThrow();

      requestAnimationFrame(animate);
    }

    function animate() {
      updatePhysics();
      render();
      update();

      requestAnimationFrame(animate);
    }

    function updatePhysics() {
      world.step(1.0 / 60.0);

      for (var i in dice) {
        dice[i].updateMeshFromBody();
      }
    }

    function update() {

      controls.update();
      if (stats) {
        stats.update();
      }
    }

    function render() {
      renderer.render(scene, camera);
    }

    init();

      //function oldInit() {
      //  console.clear();

      //  // Set the scene size.
      //  const WIDTH = 600;
      //  const HEIGHT = 300;

      //  // Set some camera attributes.
      //  const VIEW_ANGLE = 45;
      //  const ASPECT = WIDTH / HEIGHT;
      //  const NEAR = 0.1;
      //  const FAR = 10000;

      //  // Get the DOM element to attach to
      //  const container = document.querySelector('#container');

      //  // Create a WebGL renderer, camera, and a scene:
      //  const renderer = new THREE.WebGLRenderer({ alpha: true }); // new THREE.WebGLRenderer();
      //  renderer.setClearColor(0x000000, 0); // the default
      //  const camera =
      //    new THREE.PerspectiveCamera(
      //      VIEW_ANGLE,
      //      ASPECT,
      //      NEAR,
      //      FAR
      //    );

      //  const scene = new THREE.Scene();

      //  var world = new CANNON.World();
      //  DiceManager.setWorld(world);

      //  var dice = new DiceD6({ backColor: '#ff0000' }); //DiceD6 for six-sided dice; for options see DiceObject
      //  scene.add(dice.getObject());

      //  dice.getObject().position.x = 150;
      //  dice.getObject().position.y = 100;
      //  dice.getObject().rotation.x = 20 * Math.PI / 180;
      //  dice.updateBodyFromMesh();

      //  DiceManager.prepareValues([{ dice: dice, value: 6 }]);

      //  function animate() {
      //    world.step(1.0 / 60.0);

      //    dice.updateMeshFromBody(); // Call this after updating the physics world for rearranging the mesh according to the body

      //    renderer.render(scene, camera);

      //    requestAnimationFrame(animate);
      //  }
      //  requestAnimationFrame(animate);

      //  // Add the camera to the scene.
      //  scene.add(camera);

      //  // Start the renderer.
      //  renderer.setSize(WIDTH, HEIGHT);

      //  // Attach the renderer-supplied
      //  // DOM element.
      //  container.appendChild(renderer.domElement);


      //  // Set up the sphere vars
      //  const RADIUS = 90;
      //  const SEGMENTS = 16;
      //  const RINGS = 16;

      //  // create the sphere's material
      //  const sphereMaterial =
      //    new THREE.MeshLambertMaterial(
      //      {
      //        color: 0xA00050
      //      });

      //  // Create a new mesh with
      //  // sphere geometry - we will cover
      //  // the sphereMaterial next!
      //  const sphere = new THREE.Mesh(

      //    new THREE.SphereGeometry(
      //      RADIUS,
      //      SEGMENTS,
      //      RINGS),

      //    sphereMaterial);

      //  // Move the Sphere back in Z so we
      //  // can see it.
      //  sphere.position.z = -300;

      //  // Finally, add the sphere to the scene.
      //  scene.add(sphere);

      //  // create a point light
      //  const pointLight = new THREE.PointLight(0xFFFFFF);

      //  // set its position
      //  pointLight.position.x = 10;
      //  pointLight.position.y = 50;
      //  pointLight.position.z = 130;

      //  // add to the scene
      //  scene.add(pointLight);


      //  function update() {
      //    // Draw!
      //    renderer.render(scene, camera);

      //    // Schedule the next frame.
      //    requestAnimationFrame(update);
      //  }

      //  // Schedule the first frame.
      //  requestAnimationFrame(update);

      //  diceInitialize(document.body, window.innerWidth - 1, window.innerHeight - 1);
      //}

                                              // ToDo: convert dice.js to a TypeScript class.
  </script>
</body>
